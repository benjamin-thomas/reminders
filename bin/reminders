#!/usr/bin/env ruby

# For awesome_print/console output
class Time
  def inspect
    strftime("%a %d %b %Y, %H:%M")
  end
end

=begin
Priorities improvements:

Notify phone every:

prio=2400
  24 / (2400 / 100) = 1 hour
  24 / ((2400 / 100) / 60) = 60 minutes

prio=1200
  24 / (1200 / 100) = 2 hours
  24 / ((1200 / 100) / 60) = 120 minutes

prio=600
  24 / (600 / 100) = 4 hours
  24 / ((600 / 100) / 60) = 240 minutes

prio=300
  24 / (300 / 100) = 8 hours

prio=200
  24 / (200 / 100) = 12 hours
  24 / ((200 / 100) / 60) = 720 minutes

prio=100
  24 / (100 / 100) = 24 hours
  24 / ((100 / 100) / 60) = 1440 minutes

prio=4800
  24 / (4800 / 100) = 0.5 hours
  24 / ((4800 / 100) / 60) = 30 minutes

prio=72000
  2400 * 30 = 30 times in an hour, so every 2 minutes
  24 / ((72000 / 100) / 60) = 2 minutes

prio=144000
  2400 * 60 = 144000 = 60 times in an hour, so every minute
  24 / ((144000 / 100) / 60) = 1 minute


=end

require 'optparse'
require 'logger'
require 'csv'

require 'awesome_print'

ONE_MINUTE = MINUTES = 60
ONE_HOUR   = HOURS   = 60*MINUTES
ONE_DAY    = DAYS    = 24*HOURS
ONE_WEEK   = WEEKS   = 7*DAYS

# https://ruby-doc.org/stdlib-2.5.1/libdoc/readline/rdoc/Readline.html
require 'readline'

# Readline setup START
COMMANDS = [
  'ls',
  'due',
  'today',
  'search ',
  'next ',
]
COMMANDS_COMP = proc { |s| COMMANDS.grep(/^#{Regexp.escape(s)}/) }

Readline.completion_proc = COMMANDS_COMP
Readline.completion_append_character = ''
# Readline setup END

# Setup:
# apt-get install ruby-sequel ruby-sqlite3 ruby-terminal-table ruby-chronic
require 'sequel'
require 'terminal-table'
require 'chronic'

Options = Struct.new(:create_db, :notify)
args = Options.new

OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} [options]"

  opts.on('--create-db', 'Create database') do
    args.create_db = true
  end

  opts.on('--notify', 'Warn every minute about overdue reminders with notify-send') do
    args.notify = true
  end
end.parse!

ap(args)

DB_PATH = ENV.fetch('REMINDERS_DB_PATH')
DB_DIR = File.dirname(DB_PATH)
DB_EXPORT_PATH = File.join(DB_DIR, '.reminders.csv')

DB = Sequel.sqlite(DB_PATH)
DB.logger = DB_LOGGER = Logger.new(STDOUT)

if args.create_db
  DB.execute('
  CREATE TABLE IF NOT EXISTS reminders (
      id INTEGER PRIMARY KEY AUTOINCREMENT
    , pos INTEGER NOT NULL UNIQUE
    , priority INTEGER NOT NULL DEFAULT 0
    , trigger_on DATETIME NULL
    , phone_notified_on DATETIME NULL
    , descr VARCHAR(255) NOT NULL
  );
             ')
  p(:CREATE_DB_OK)
  exit
end

class Reminder < Sequel::Model(DB[:reminders])
  BY_TRIGGER_ON = [
    Sequel.lit('CASE WHEN trigger_on IS NULL THEN 1 ELSE 0 END, trigger_on ASC'),
    Sequel.desc(:priority),
  ]
  BY_PRIORITY = [
    Sequel.desc(:priority),
    Sequel.asc(:trigger_on),
  ]

  def self.prioritized
    where{ priority >= 0 }
  end

  def self.next_available_pos
    DB.logger = nil
    i = 0
    loop do
      i += 1
      if find(pos: i).nil?
        return(i)
      end
    end
  ensure
    DB.logger = DB_LOGGER
  end

  def self.compute_code(code:, from:)
    suffix = code[-1]
    i = Integer(code[0..-2])
    next_trigger_on = case suffix
                      when 'm'
                        from + i*MINUTES
                      when 'h'
                        from + i*HOURS
                      when 'd'
                        from + i*DAYS
                      when 'w'
                        from + i*WEEKS
                      when 'M'
                        (from.to_datetime >> 1).to_time
                      else
                        fail 'Impossible'
                      end
  end

  def self.next(code)
    from = compute_code(code: code, from: Time.now)

    prioritized
      .where{ trigger_on < from }
  end

  def reschedule(from:, code:)
    next_trigger_on = Reminder.compute_code(code: code, from: from)
    res = update(trigger_on: next_trigger_on)
    p(:RESCHEDULE_OK)
    ap(res)
  end

  def notify_phone_required?
    return false if priority < 100
    return true if phone_notified_on.nil?

    last_notified_since = Integer(Time.now - phone_notified_on)
    retrigger_after = 24 / (priority/100.0/60.0)
    return last_notified_since > retrigger_after*MINUTES
  end

  def validate
    super
    errors.add(:priority, 'cannot be nil') if priority.nil?
    errors.add(:priority, 'is too high') if priority && priority > 4800
    errors.add(:descr, 'cannot be empty') if descr.nil? || descr.empty?
    errors.add(:trigger_on, 'cannot be empty on non negative priority') if priority >= 0 && trigger_on.nil?
    errors.add(:trigger_on, 'should be nil on negative priority') if priority < 0 && trigger_on
  end
end

def table(reminders)
  headings = [:pos, :priority, :trigger_on, :descr]
  rs = reminders.map do |r|
    #r.values.values_at(*headings)
    descr = if r.descr.include?(';')
              r.descr.split(';').first + '[MORE]'
            else
              r.descr
    end
    [
      r.pos,
      r.priority,
      r.trigger_on&.strftime("%Y-%m-%d %H:%M (%a)"),
      descr,
    ]
  end
  table = Terminal::Table.new(
    headings: headings,
    rows: rs,
  )
  puts(table)
end

def by_priority
  [Sequel.desc(:priority), Sequel.asc(:trigger_on)]
end

def by_trigger_on
  # [:trigger_on, Sequel.desc(:priority)]
  [Sequel.lit('CASE WHEN trigger_on IS NULL THEN 1 ELSE 0 END, trigger_on ASC'), Sequel.desc(:priority)]
end

def all_by_priority
  Reminder.order(*by_priority)
end

def all_by_trigger_on
  Reminder.order(*by_trigger_on)
end

OVERDUE_COND = proc do
  (priority >=0) & (trigger_on <= Time.now)
end

def overdues_by_priority
  all_by_priority.where(&OVERDUE_COND)
end

def overdues_by_trigger_on
  all_by_trigger_on.where(&OVERDUE_COND)
end

TODAY_COND = proc do
  (priority >=0) & (trigger_on < Date.today+1)
end

# TODO: use Reminder.prioritized and move into model
def scheduled_today_by_priority
  all_by_priority.where(&TODAY_COND)
end

# TODO: use Reminder.prioritized and move into model
def scheduled_today_by_trigger_on
  all_by_trigger_on.where(&TODAY_COND)
end

def ask(attribute, prefill = nil)
  if prefill
    Readline.pre_input_hook = -> {
      Readline.insert_text(prefill.to_s)
      Readline.redisplay
    }
  end

  line = Readline.readline("#{attribute}: ")

  Readline.pre_input_hook = nil
  res = line.rstrip
  return nil if res.empty?

  res
end

def ensure_date(val)
  # return if val.nil?
  # Date.parse('2018-09-01')
  Chronic.parse(val)
end

def build_reminder(descr:, trigger_on:, priority:)
  {
    descr: ask('descr', descr),
    trigger_on: ensure_date(ask('trigger_on', trigger_on)),
    priority: ask('priority', priority),
  }
end

def edit_reminder(pos)
  r = Reminder.first!(pos: pos)
  [r, build_reminder(descr: r.descr, trigger_on: r.trigger_on, priority: r.priority)]
end

def testdate
  Readline.completion_proc = proc{}
  puts "[INFO] type `exit` to exit loop"
  puts "[INFO] try `next monday at 8pm`, `2 weeks hence`"
  loop do
    while (line = Readline.readline('testdate> ', true))
      datestr = line.rstrip
      return if datestr == 'exit'

      ts = Chronic.parse(datestr)
      ts2 = IO.popen(['date', '-R', '-d', datestr]) { |f| f.gets&.chomp }
      ap(
        default: ts,
        alt: ts2,
      )
    end
  end
ensure
  Readline.completion_proc = COMMANDS_COMP
end

def run_cli
  puts "[INFO] type `help` to display usage summary"
  while (line = Readline.readline('> ', true))
    cmd = line.rstrip
    case cmd
    when 'help'
      puts <<~EOS

      - 123<ENTER>       : edit reminder with POS=123
      - ! 123<ENTER>      : delete reminder POS=123
      - >CODE 123<ENTER> : reschedule reminder POS=123
          CODE can be as follows:
            - 10m  : trigger in 10 minutes
            -  3h  : trigger in 3 hours
            -  5d  : trigger in 5 days
            -  2w  : trigger in 2 weeks
            -  3M  : trigger in 3 months
      - +CODE 123<ENTER> : reschedule reminder POS=123, but use last trigger timestamp as reference
            - 24h  : retrigger at same HH:MM, on the next day

      Commands below are mostly available via tab completion

      - ls               : list prioritized (triggering) reminders by trigger timestamp first
      - ls2              : list all reminders by priority first
      - due              : list overdue reminders by priority first
      - due2             : list overdue reminders by trigger timestamp first
      - today            : list reminders scheduled for today by timestamp first
      - today2           : list reminders scheduled for today by priority first
      - search           : list reminders based on descr
      - next CODE        : list reminders that will trigger in CODE (see above), by trigger_on
      - next2 CODE       : list reminders that will trigger in CODE (see above), by priority

      Commands without tab completion (rarely used)

      - export           : export data to '#{DB_EXPORT_PATH}'
      - import           : restore data from '#{DB_EXPORT_PATH}'
      - testdate         : datestrings REPL
      EOS
    when 'ls'
      table(all_by_trigger_on)
    when 'ls2'
      table(all_by_priority)
    when 'due'
      table(overdues_by_priority)
    when 'due2'
      table(overdues_by_trigger_on)
    when 'today'
      table(scheduled_today_by_trigger_on)
    when 'today2'
      table(scheduled_today_by_priority)
    when 'testdate'
      testdate
    when 'export'
      CSV.open(DB_EXPORT_PATH, 'wb') do |csv|
        csv << ['priority', 'trigger_on', 'descr' ]
        Reminder.all do |r|
          csv << [r.priority, r.trigger_on, r.descr]
        end
      end
      p(:OK)
      print("Inspect export? (y|N)")
      answer = gets.chomp
      if answer == 'y'
        # apt install csvtool
        puts `csvtool readable "#{DB_EXPORT_PATH}"`

        # pip install tabview
        # system('tabview', DB_EXPORT_PATH)
      end
    when 'import'
      CSV.foreach(DB_EXPORT_PATH, headers: true) do |row|

        Reminder.insert(
          pos: Reminder.next_available_pos,
          descr: row.fetch('descr'),
          trigger_on: row.fetch('trigger_on'),
          priority: row.fetch('priority'),
        )
      end
    else
      if (m = /^! (?<pos>\d+)/.match(cmd)) # delete
        # Don't like log message of query below (generates 2 queries, confusing UI wise)
        DB.logger = nil
        r = Reminder.find(pos: m[:pos])
        r.delete
        DB.logger = DB_LOGGER
        ap(r)
        p(:DELETE_OK)
        table(overdues_by_priority)

        next
      elsif (m = /^>(?<code>\d+[mhdwM])\s(?<pos>\d+)/.match(cmd)) # reschedule from now
        r = Reminder.find(pos: m[:pos])
        r.reschedule(from: Time.now, code: m[:code])

        table(overdues_by_priority)
        next
      elsif (m = /^\+(?<code>\d+[mhdwM])\s(?<pos>\d+)/.match(cmd)) # reschedule from last trigger timestamp
        r = Reminder.find(pos: m[:pos])
        r.reschedule(from: r.trigger_on, code: m[:code])

        table(overdues_by_priority)
        next
      elsif (m = /next (?<code>\d+[mhdwM])/.match(cmd)) # next
        table(
          Reminder.next(m[:code]).order(*Reminder::BY_TRIGGER_ON)
        )
        next
      elsif (m = /next2 (?<code>\d+[mhdwM])/.match(cmd)) # next
        table(
          Reminder.next(m[:code]).order(*Reminder::BY_PRIORITY)
        )
        next
      elsif (m = /^(?<pos>\d+)/.match(cmd)) # edit
        loop do
          r, h = edit_reminder(m[:pos])
          ap(h)
          r.descr = h.fetch(:descr)
          r.trigger_on = h.fetch(:trigger_on)
          r.priority =  h.fetch(:priority)
          if r.valid?
            r.save
            break
          end
          ap(r.errors)
        end
        table(overdues_by_priority)
        next
      elsif (m = /^search (?<string>.+\Z)/.match(cmd)) # search
        table(
          Reminder.where(Sequel.ilike(:descr, "%" + m[:string] + "%"))
        )
        next
      end

      # create
      loop do
        br = build_reminder(descr: cmd, trigger_on: Time.now + ONE_HOUR, priority: 0)
        pos = Reminder.next_available_pos
        r = Reminder.new(
          pos: pos,
          descr: br.fetch(:descr),
          trigger_on: br.fetch(:trigger_on),
          priority: br.fetch(:priority),
        )
        if r.valid?
          r.save
          ap(r)
          break
        else
          p(r.errors)
        end
      end
      p(:CREATE_OK)
    end
  end
end

def run_notifier!
  loop do
    overdues = overdues_by_priority
    overdues.each do |o|
      notify_msg = "[#{o.pos}] Priority=#{o.priority}: #{o.descr}"
      system('notify-send', '-u', 'critical', notify_msg)
      if o.notify_phone_required?
        system('push_to_phone', notify_msg[0,140]) # TODO: handle max 140 in push_to_phone later
        o.update(phone_notified_on: Time.now)
      end
    end
    sleep(1)
  end
end

if args.notify
  run_notifier!
  fail 'Impossible'
end

run_cli
