#!/usr/bin/env ruby

require 'optparse'
require 'json'
require 'logger'

require 'awesome_print'

ONE_HOUR = 60 * 60

# https://ruby-doc.org/stdlib-2.5.1/libdoc/readline/rdoc/Readline.html
require 'readline'

# Readline setup START
COMMANDS = [
  'all',
  'overdues',
  'rm ',
  'edit ',
]
COMMANDS_COMP = proc { |s| COMMANDS.grep(/^#{Regexp.escape(s)}/) }

Readline.completion_proc = COMMANDS_COMP
Readline.completion_append_character = ''
# Readline setup END

# Setup:
# apt-get install ruby-sequel ruby-sqlite3 ruby-terminal-table ruby-chronic
require 'sequel'
require 'terminal-table'
require 'chronic'

Options = Struct.new(:create_db)
args = Options.new

OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} [options]"

  opts.on('-c', '--create-db', 'Create database') do
    args.create_db = true
  end
end.parse!

ap(args)

DB = Sequel.sqlite(File.expand_path('~/.reminders.sqlite'))
DB.logger = Logger.new(STDOUT)

DB.execute('
  CREATE TABLE IF NOT EXISTS reminders (
      id INTEGER PRIMARY KEY AUTOINCREMENT
    , priority INTEGER NOT NULL DEFAULT 0
    , trigger_on DATETIME NULL
    , descr VARCHAR(255) NOT NULL
  );
')

# Reminder = DB[:reminders]

class Reminder < Sequel::Model(DB[:reminders])
  def validate
    super
    errors.add(:priority, 'cannot be nil') if priority.nil?
    errors.add(:descr, 'cannot be empty') if descr.nil? || descr.empty?
    errors.add(:trigger_on, 'cannot be empty on non negative priority') if priority >= 0 && trigger_on.nil?
    errors.add(:trigger_on, 'should be nil on negative priority') if priority < 0 && trigger_on
  end
end

def table(reminders)
  rs = reminders.map { |r| r.values.values_at(:id, :priority, :trigger_on, :descr) }
  table = Terminal::Table.new(
    headings: [:id, :priority, :trigger_on, :descr],
    rows: rs,
  )
  puts(table)
end

def by_priority
  [Sequel.desc(:priority), Sequel.asc(:trigger_on)]
end

def by_trigger_on
  # [:trigger_on, Sequel.desc(:priority)]
  [Sequel.lit('CASE WHEN trigger_on IS NULL THEN 1 ELSE 0 END, trigger_on ASC'), Sequel.desc(:priority)]
end

def all_by_priority
  Reminder.order(*by_priority)
end

def all_by_trigger_on
  Reminder.order(*by_trigger_on)
end

OVERDUE_COND = proc do
  (priority >=0) & (trigger_on <= Time.now)
end

def overdues_by_priority
  all_by_priority.where(&OVERDUE_COND)
end

def overdues_by_trigger_on
  all_by_trigger_on.where(&OVERDUE_COND)
end

def ask(attribute, prefill = nil)
  if prefill
    Readline.pre_input_hook = -> {
      Readline.insert_text(prefill.to_s)
      Readline.redisplay
    }
  end

  line = Readline.readline("#{attribute}: ")

  Readline.pre_input_hook = nil
  res = line.rstrip
  return nil if res.empty?

  res
end

def ensure_date(val)
  # return if val.nil?
  # Date.parse('2018-09-01')
  Chronic.parse(val)
end

def build_reminder(descr:, trigger_on:, priority:)
  {
    descr: ask('descr', descr),
    trigger_on: ensure_date(ask('trigger_on', trigger_on)),
    priority: ask('priority', priority),
  }
end

def edit_reminder(id)
  r = Reminder.first!(id: id)
  [r, build_reminder(descr: r.descr, trigger_on: r.trigger_on, priority: r.priority)]
end

while (line = Readline.readline('> ', true))
  cmd = line.rstrip
  case cmd
  when 'all'
    table(all_by_priority)
  when 'all2'
    table(all_by_trigger_on)
  when 'overdues'
    table(overdues_by_priority)
  when 'overdues2'
    table(overdues_by_trigger_on)
  when 'create'
  else
    if (m = /^rm (?<id>\d+)/.match(cmd))
      Reminder.find(id: m[:id]).delete
      next
    elsif (m = /^edit (?<id>\d+)/.match(cmd))
      loop do
        r, h = edit_reminder(m[:id])
        ap(h)
        r.descr = h.fetch(:descr)
        r.trigger_on = h.fetch(:trigger_on)
        r.priority =  h.fetch(:priority)
        if r.valid?
          r.save
          break
        end
        ap(r.errors)
      end
      next
    end

    r = build_reminder(descr: cmd, trigger_on: Time.now + ONE_HOUR, priority: 0)
    ap(r)
    Reminder.insert(
      descr: r.fetch(:descr),
      trigger_on: r.fetch(:trigger_on),
      priority: r.fetch(:priority),
    )
  end
end
