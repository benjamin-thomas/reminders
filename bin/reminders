#!/usr/bin/env ruby

# For awesome_print/console output
class Time
  def inspect
    strftime("%a %d %b %Y, %H:%M [%V]")
  end
end

$track_longuest = false

=begin
Priorities improvements:

Notify phone every:

prio=2400
  24 / (2400 / 100) = 1 hour
  24 / ((2400 / 100) / 60) = 60 minutes

prio=1200
  24 / (1200 / 100) = 2 hours
  24 / ((1200 / 100) / 60) = 120 minutes

prio=600
  24 / (600 / 100) = 4 hours
  24 / ((600 / 100) / 60) = 240 minutes

prio=300
  24 / (300 / 100) = 8 hours

prio=200
  24 / (200 / 100) = 12 hours
  24 / ((200 / 100) / 60) = 720 minutes

prio=100
  24 / (100 / 100) = 24 hours
  24 / ((100 / 100) / 60) = 1440 minutes

prio=4800
  24 / (4800 / 100) = 0.5 hours
  24 / ((4800 / 100) / 60) = 30 minutes

prio=72000
  2400 * 30 = 30 times in an hour, so every 2 minutes
  24 / ((72000 / 100) / 60) = 2 minutes

prio=144000
  2400 * 60 = 144000 = 60 times in an hour, so every minute
  24 / ((144000 / 100) / 60) = 1 minute


=end

require 'optparse'
require 'logger'
require 'csv'
require 'fileutils'

require 'awesome_print'
require 'dbus' # gem install --user ruby-dbus
=begin
To read:

- https://dbus.freedesktop.org/doc/dbus-tutorial.html
- http://www.linuxembedded.fr/2015/07/comprendre-dbus/
- https://yoannsculo.developpez.com/tutoriels/linux/introduction-dbus/
- http://www.kaizou.org/2014/06/dbus-command-line/
=end


SESSION_BUS = DBus.session_bus
NOTIFICATION_SERVICE   = SESSION_BUS["org.freedesktop.Notifications"]
NOTIFICATION_OBJECT    = NOTIFICATION_SERVICE["/org/freedesktop/Notifications"]
NOTIFICATION_INTERFACE = NOTIFICATION_OBJECT["org.freedesktop.Notifications"]

# Look for section "Basic types": https://dbus.freedesktop.org/doc/dbus-specification.html
DBUS_ASCII_TYPE_CODE = {
  byte: 'y',
}

# https://developer.gnome.org/notification-spec/
NOTIFY_URGENCY = {
       low: 0,
    normal: 1,
  critical: 2,
}
NOTIFY_TIMEOUT = {
  default: -1,
    never:  0,
}

ONE_MINUTE = MINUTES = 60
ONE_HOUR   = HOURS   = 60*MINUTES
ONE_DAY    = DAYS    = 24*HOURS
ONE_WEEK   = WEEKS   = 7*DAYS

# https://ruby-doc.org/stdlib-2.5.1/libdoc/readline/rdoc/Readline.html
require 'readline'

# Readline setup START
COMMANDS = [
  'ls',
  'due',
  'today',
  'search ',
  'next ',
  'track_longuest',
]
COMMANDS_COMP = proc { |s| COMMANDS.grep(/^#{Regexp.escape(s)}/) }

Readline.completion_proc = COMMANDS_COMP
Readline.completion_append_character = ''
# Readline setup END

# Setup:
# apt-get install ruby-sequel ruby-sqlite3 ruby-terminal-table ruby-chronic
require 'sequel'
require 'terminal-table'
require 'chronic'

Options = Struct.new(:create_db, :recreate_db, :notify)
args = Options.new

OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} [options]"

  opts.on('--create-db', 'Create database') do
    args.create_db = true
  end

  opts.on('--recreate-db', 'Recreate database (use after export, then import)') do
    args.recreate_db = true
  end

  opts.on('--notify', 'Warn every minute about overdue reminders with notify-send') do
    args.notify = true
  end
end.parse!

ap(args)

DB_PATH = ENV.fetch('REMINDERS_DB_PATH')
DB_DIR = File.dirname(DB_PATH)
DB_EXPORT_PATH = File.join(DB_DIR, '.reminders.csv')

DB = Sequel.sqlite(DB_PATH)
DB.logger = DB_LOGGER = Logger.new(STDOUT)

def create_db!
  DB.execute('
  CREATE TABLE reminders (
      id INTEGER PRIMARY KEY AUTOINCREMENT
    , priority INTEGER NOT NULL DEFAULT 0
    , trigger_on DATETIME NULL
    , notification_id INTEGER NULL
    , phone_notified_on DATETIME NULL
    , descr VARCHAR(255) NOT NULL
  );
             ')
  p(:CREATE_DB_OK)
end

if args.create_db
  create_db!
  exit
end

if args.recreate_db
  if File.exist?(DB_PATH)
    bak_path = "#{DB_PATH}.bak.#{Time.now.to_i}"
    FileUtils::Verbose::mv(DB_PATH, bak_path)
  end
  system($0, "--create-db") # just in case
end

class Reminder < Sequel::Model(DB[:reminders])
  BY_TRIGGER_ON_FIRST = [
    Sequel.lit('CASE WHEN trigger_on IS NULL THEN 1 ELSE 0 END, trigger_on ASC'),
    Sequel.desc(:priority),
  ]
  BY_PRIORITY_FIRST = [
    Sequel.desc(:priority),
    Sequel.asc(:trigger_on),
  ]

  def self.prioritized
    where{ priority >= 0 }
  end

  def self.compute_code(code:, from:)
    suffix = code[-1]
    i = Integer(code[0..-2])
    next_trigger_on = case suffix
                      when 'm'
                        from + i*MINUTES
                      when 'h'
                        from + i*HOURS
                      when 'd'
                        from + i*DAYS
                      when 'w'
                        from + i*WEEKS
                      when 'M'
                        (from.to_datetime >> i).to_time
                      else
                        fail 'Impossible'
                      end
  end

  def self.next(code)
    from = compute_code(code: code, from: Time.now)

    prioritized
      .where{ trigger_on < from }
  end

  def reschedule(from:, code:)
    next_trigger_on = Reminder.compute_code(code: code, from: from)
    res = update(trigger_on: next_trigger_on)
    p(:RESCHEDULE_OK)
    ap(res)
  end

  def notify_phone_required?
    return false if priority < 100
    return true if phone_notified_on.nil?

    last_notified_since = Integer(Time.now - phone_notified_on)
    retrigger_after = 24 / (priority/100.0/60.0)
    return last_notified_since > retrigger_after*MINUTES
  end

  def validate
    super
    errors.add(:priority, 'cannot be nil') if priority.nil?
    errors.add(:priority, 'is too high') if priority && priority > 4800
    errors.add(:descr, 'cannot be empty') if descr.nil? || descr.empty?
    errors.add(:trigger_on, 'cannot be empty on non negative priority') if priority >= 0 && trigger_on.nil?
    errors.add(:trigger_on, 'should be nil on negative priority') if priority < 0 && trigger_on
  end

  def notify!
    # dbus-monitor --session interface='org.freedesktop.Notifications'
    notify_msg = "[#{id}] Priority=#{priority}: #{descr}"
    # Inspect args
    # NOTIFICATION_INTERFACE.methods['Notify']

    do_not_replace = 0
    replaces_id = notification_id || do_not_replace
    icon = ''
    title = 'Reminder'
    actions = []
    critical_variant = DBus.variant(DBUS_ASCII_TYPE_CODE.fetch(:byte), NOTIFY_URGENCY.fetch(:critical))
    hints = {'urgency' => critical_variant }
    timeout = NOTIFY_TIMEOUT.fetch(:never)
    nid = NOTIFICATION_INTERFACE.Notify(
      'reminder',
      replaces_id,
      icon,
      title,
      notify_msg,
      actions,
      hints,
      timeout,
    )

    if notification_id != nid  # first notified or notification server has restarted
      update(notification_id: nid)
    end
  end

  def remove_notification!
    NOTIFICATION_INTERFACE.CloseNotification(notification_id)
  end

end

def table(reminders)
  headings = [:id, :priority, :trigger_on, :descr]
  longuest = {
    id: nil,
    size: 0,
  }
  rs = reminders.map do |r|
    #r.values.values_at(*headings)
    descr = if r.descr.include?(';')
              r.descr.split(';').first + '[MORE]'
            else
              r.descr
            end

    if descr.size > longuest.fetch(:size)
      longuest[:id] = r.id
      longuest[:size] = descr.size
    end

    [
      r.id,
      r.priority,
      r.trigger_on&.strftime("%Y-%m-%d %H:%M (%a) [%V]"),
      descr,
    ]
  end
  table = Terminal::Table.new(
    headings: headings,
    rows: rs,
  )

  cnt = rs.count
  case cnt
  when 0
    puts "No records found"
  when 1
    puts(table)
    puts "1 record found"
  else
    puts(table)
    puts "#{cnt} records found"
  end

  if $track_longuest
    puts("longuest=#{longuest}")
  end
end

def by_priority
  [Sequel.desc(:priority), Sequel.asc(:trigger_on)]
end

def by_trigger_on
  # [:trigger_on, Sequel.desc(:priority)]
  [Sequel.lit('CASE WHEN trigger_on IS NULL THEN 1 ELSE 0 END, trigger_on ASC'), Sequel.desc(:priority)]
end

def all_by_priority
  Reminder.order(*by_priority)
end

def all_by_trigger_on
  Reminder.order(*by_trigger_on)
end

OVERDUE_COND = proc do
  (priority >=0) & (trigger_on <= Time.now)
end

def overdues_by_priority
  all_by_priority.where(&OVERDUE_COND)
end

def overdues_by_trigger_on
  all_by_trigger_on.where(&OVERDUE_COND)
end

TODAY_COND = proc do
  (priority >=0) & (trigger_on < Date.today+1)
end

# TODO: use Reminder.prioritized and move into model
def scheduled_today_by_priority
  all_by_priority.where(&TODAY_COND)
end

# TODO: use Reminder.prioritized and move into model
def scheduled_today_by_trigger_on
  all_by_trigger_on.where(&TODAY_COND)
end

def ask(attribute, prefill = nil)
  if prefill
    Readline.pre_input_hook = -> {
      Readline.insert_text(prefill.to_s)
      Readline.redisplay
    }
  end

  line = Readline.readline("#{attribute}: ")

  Readline.pre_input_hook = nil
  res = line.rstrip
  return nil if res.empty?

  res
end

def ensure_date(val)
  # return if val.nil?
  # Date.parse('2018-09-01')
  Chronic.parse(val)
end

def build_reminder(descr:, trigger_on:, priority:)
  {
    descr: ask('descr', descr),
    trigger_on: ensure_date(ask('trigger_on', trigger_on)),
    priority: ask('priority', priority),
  }
end

def edit_reminder(id)
  r = Reminder.first!(id: id)
  [r, build_reminder(descr: r.descr, trigger_on: r.trigger_on, priority: r.priority)]
end

def testdate
  Readline.completion_proc = proc{}
  puts "[INFO] type `exit` to exit loop"
  puts "[INFO] try `next monday at 8pm`, `2 weeks hence`"
  loop do
    while (line = Readline.readline('testdate> ', true))
      datestr = line.rstrip
      return if datestr == 'exit'

      ts = Chronic.parse(datestr)
      ts2 = IO.popen(['date', '-R', '-d', datestr]) { |f| f.gets&.chomp }
      ap(
        default: ts,
        alt: ts2,
      )
    end
  end
ensure
  Readline.completion_proc = COMMANDS_COMP
end

def run_cli
  puts "[INFO] type `help` to display usage summary"
  while (line = Readline.readline('> ', true))
    cmd = line.rstrip
    case cmd
    when 'help'
      puts <<~EOS

      - 123<ENTER>       : edit reminder with ID=123
      - ! 123<ENTER>      : delete reminder ID=123
      - >CODE 123<ENTER> : reschedule reminder ID=123
          CODE can be as follows:
            - 10m  : trigger in 10 minutes
            -  3h  : trigger in 3 hours
            -  5d  : trigger in 5 days
            -  2w  : trigger in 2 weeks
            -  3M  : trigger in 3 months
      - +CODE 123<ENTER> : reschedule reminder ID=123, but use last trigger timestamp as reference
            - 24h  : retrigger at same HH:MM, on the next day

      Commands below are mostly available via tab completion

      - ls               : list prioritized (triggering) reminders by trigger timestamp first
      - ls2              : list all reminders by priority first
      - due              : list overdue reminders by priority first
      - due2             : list overdue reminders by trigger timestamp first
      - today            : list reminders scheduled for today by timestamp first
      - today2           : list reminders scheduled for today by priority first
      - search           : list reminders based on descr
      - next CODE        : list reminders that will trigger in CODE (see above), by trigger_on
      - next2 CODE       : list reminders that will trigger in CODE (see above), by priority
      - track_longuest   : track_longuest string (fix unreadable output)

      Commands without tab completion (rarely used)

      - export           : export data to '#{DB_EXPORT_PATH}'
      - import           : restore data from '#{DB_EXPORT_PATH}'
      - testdate         : datestrings REPL
      EOS
    when 'ls'
      table(all_by_trigger_on)
    when 'ls2'
      table(all_by_priority)
    when 'due'
      table(overdues_by_priority)
    when 'due2'
      table(overdues_by_trigger_on)
    when 'today'
      table(scheduled_today_by_trigger_on)
    when 'today2'
      table(scheduled_today_by_priority)
    when 'testdate'
      testdate
    when 'track_longuest'
      $track_longuest = !$track_longuest
      puts($track_longuest ? 'ON' : 'OFF')
      next
    when 'export'
      if File.exist?(DB_EXPORT_PATH)
        bak_path = "#{DB_EXPORT_PATH}.bak.#{Time.now.to_i}"
        FileUtils::Verbose::mv(DB_EXPORT_PATH, bak_path)
      end
      CSV.open(DB_EXPORT_PATH, 'wb') do |csv|
        csv << ['priority', 'trigger_on', 'descr' ]
        Reminder.order(*Reminder::BY_TRIGGER_ON_FIRST).all do |r|
          csv << [r.priority, r.trigger_on, r.descr]
        end
      end
      p(:OK)
      print("Inspect export? (y|N)")
      answer = gets.chomp
      if answer == 'y'
        # apt install csvtool
        puts `csvtool readable "#{DB_EXPORT_PATH}"`

        # pip install tabview
        # system('tabview', DB_EXPORT_PATH)
      end
      puts "Inspect with: 'tabview #{DB_EXPORT_PATH}'"
    when 'import'
      CSV.foreach(DB_EXPORT_PATH, headers: true) do |row|

        Reminder.insert(
          descr: row.fetch('descr'),
          trigger_on: row.fetch('trigger_on'),
          priority: row.fetch('priority'),
        )
      end
    else
      if (m = /^! (?<id>\d+)/.match(cmd)) # delete
        r = Reminder.first!(id: m[:id])
        r.delete
        r.remove_notification!
        ap(r)
        p(:DELETE_OK)
        table(overdues_by_priority)


        next
      elsif (m = /^>(?<code>\d+[mhdwM])\s(?<id>\d+)/.match(cmd)) # reschedule from now
        r = Reminder.first!(id: m[:id])
        r.reschedule(from: Time.now, code: m[:code])
        r.remove_notification!

        table(overdues_by_priority)
        next
      elsif (m = /^\+(?<code>\d+[mhdwM])\s(?<id>\d+)/.match(cmd)) # reschedule from last trigger timestamp
        r = Reminder.first!(id: m[:id])
        r.reschedule(from: r.trigger_on, code: m[:code])
        r.remove_notification!

        table(overdues_by_priority)
        next
      elsif (m = /next (?<code>\d+[mhdwM])/.match(cmd)) # next
        table(
          Reminder.next(m[:code]).order(*Reminder::BY_TRIGGER_ON_FIRST)
        )
        next
      elsif (m = /next2 (?<code>\d+[mhdwM])/.match(cmd)) # next
        table(
          Reminder.next(m[:code]).order(*Reminder::BY_PRIORITY_FIRST)
        )
        next
      elsif (m = /^(?<id>\d+)/.match(cmd)) # edit
        loop do
          r, h = edit_reminder(m[:id])
          ap(h)
          r.descr = h.fetch(:descr)
          r.trigger_on = h.fetch(:trigger_on)
          r.priority =  h.fetch(:priority)
          if r.valid?
            r.save
            r.remove_notification!
            break
          end
          ap(r.errors)
        end
        table(overdues_by_priority)

        next
      elsif (m = /^search (?<string>.+\Z)/.match(cmd)) # search
        table(
          Reminder
            .where(Sequel.ilike(:descr, "%" + m[:string] + "%"))
            .order(*Reminder::BY_PRIORITY_FIRST)
        )
        next
      end

      # create
      loop do
        br = build_reminder(descr: cmd, trigger_on: Time.now + ONE_HOUR, priority: 0)
        r = Reminder.new(
          descr: br.fetch(:descr),
          trigger_on: br.fetch(:trigger_on),
          priority: br.fetch(:priority),
        )
        if r.valid?
          r.save
          ap(r)
          break
        else
          p(r.errors)
        end
      end
      p(:CREATE_OK)
    end
  end
end

def run_notifier!
  Reminder.dataset.update(notification_id: nil) # start with fresh ids in case of notification restart
  loop do
    overdues = overdues_by_priority
    overdues.each do |o|
      o.notify!
      if o.notify_phone_required?
        system('push_to_phone', notify_msg[0,140]) # TODO: handle max 140 in push_to_phone later
        o.update(phone_notified_on: Time.now)
      end
    end
    sleep(1)
  end
end

if args.notify
  run_notifier!
  fail 'Impossible'
end

run_cli
