#!/usr/bin/env ruby

require 'optparse'
require 'logger'
require 'csv'

require 'awesome_print'

ONE_MINUTE = 60
ONE_HOUR   = ONE_MINUTE * 60
ONE_DAY    = ONE_HOUR * 24

# https://ruby-doc.org/stdlib-2.5.1/libdoc/readline/rdoc/Readline.html
require 'readline'

# Readline setup START
COMMANDS = [
  'ls',
  'due',
  'today',
]
COMMANDS_COMP = proc { |s| COMMANDS.grep(/^#{Regexp.escape(s)}/) }

Readline.completion_proc = COMMANDS_COMP
Readline.completion_append_character = ''
# Readline setup END

# Setup:
# apt-get install ruby-sequel ruby-sqlite3 ruby-terminal-table ruby-chronic
require 'sequel'
require 'terminal-table'
require 'chronic'

Options = Struct.new(:create_db, :notify)
args = Options.new

OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} [options]"

  opts.on('--create-db', 'Create database') do
    args.create_db = true
  end

  opts.on('--notify', 'Warn every minute about overdue reminders with notify-send') do
    args.notify = true
  end
end.parse!

ap(args)

DB_PATH = ENV.fetch('REMINDERS_DB_PATH')
DB_DIR = File.dirname(DB_PATH)
DB_EXPORT_PATH = File.join(DB_DIR, '.reminders.csv')

DB = Sequel.sqlite(DB_PATH)
DB.logger = Logger.new(STDOUT)

if args.create_db
  DB.execute('
  CREATE TABLE IF NOT EXISTS reminders (
      id INTEGER PRIMARY KEY AUTOINCREMENT
    , pos INTEGER NOT NULL UNIQUE
    , priority INTEGER NOT NULL DEFAULT 0
    , trigger_on DATETIME NULL
    , descr VARCHAR(255) NOT NULL
  );
             ')
end

class Reminder < Sequel::Model(DB[:reminders])
  def self.next_available_pos
    i = 0
    loop do
      i += 1
      if find(pos: i).nil?
        return(i)
      end
    end
  end

  def validate
    super
    errors.add(:priority, 'cannot be nil') if priority.nil?
    errors.add(:descr, 'cannot be empty') if descr.nil? || descr.empty?
    errors.add(:trigger_on, 'cannot be empty on non negative priority') if priority >= 0 && trigger_on.nil?
    errors.add(:trigger_on, 'should be nil on negative priority') if priority < 0 && trigger_on
  end
end

def table(reminders)
  rs = reminders.map { |r| r.values.values_at(:pos, :priority, :trigger_on, :descr) }
  table = Terminal::Table.new(
    headings: [:pos, :priority, :trigger_on, :descr],
    rows: rs,
  )
  puts(table)
end

def by_priority
  [Sequel.desc(:priority), Sequel.asc(:trigger_on)]
end

def by_trigger_on
  # [:trigger_on, Sequel.desc(:priority)]
  [Sequel.lit('CASE WHEN trigger_on IS NULL THEN 1 ELSE 0 END, trigger_on ASC'), Sequel.desc(:priority)]
end

def all_by_priority
  Reminder.order(*by_priority)
end

def all_by_trigger_on
  Reminder.order(*by_trigger_on)
end

OVERDUE_COND = proc do
  (priority >=0) & (trigger_on <= Time.now)
end

def overdues_by_priority
  all_by_priority.where(&OVERDUE_COND)
end

def overdues_by_trigger_on
  all_by_trigger_on.where(&OVERDUE_COND)
end

TODAY_COND = proc do
  (priority >=0) & (trigger_on < Date.today+1)
end

def scheduled_today_by_priority
  all_by_priority.where(&TODAY_COND)
end

def scheduled_today_by_trigger_on
  all_by_trigger_on.where(&TODAY_COND)
end

def ask(attribute, prefill = nil)
  if prefill
    Readline.pre_input_hook = -> {
      Readline.insert_text(prefill.to_s)
      Readline.redisplay
    }
  end

  line = Readline.readline("#{attribute}: ")

  Readline.pre_input_hook = nil
  res = line.rstrip
  return nil if res.empty?

  res
end

def ensure_date(val)
  # return if val.nil?
  # Date.parse('2018-09-01')
  Chronic.parse(val)
end

def build_reminder(descr:, trigger_on:, priority:)
  {
    descr: ask('descr', descr),
    trigger_on: ensure_date(ask('trigger_on', trigger_on)),
    priority: ask('priority', priority),
  }
end

def edit_reminder(pos)
  r = Reminder.first!(pos: pos)
  [r, build_reminder(descr: r.descr, trigger_on: r.trigger_on, priority: r.priority)]
end

def run_cli
  puts "[INFO] type `help` to display usage summary"
  while (line = Readline.readline('> ', true))
    cmd = line.rstrip
    case cmd
    when 'help'
      puts <<~EOS

      - 123<ENTER>       : edit reminder with POS=123
      - !123<ENTER>      : delete reminder POS=123
      - >123 CODE<ENTER> : reschedule reminder POS=123
          CODE can be as follows:
            - 10m  : trigger in 10 minutes
            -  3h  : trigger in 3 hours
            -  5d  : trigger in 5 days

      Commands below are mostly available via tab completion

      - ls               : list reminders by trigger timestamp first
      - ls2              : list reminders by priority first
      - due              : list overdue reminders by priority first
      - due2             : list overdue reminders by trigger timestamp first
      - today            : list reminders scheduled for today by timestamp first
      - today2           : list reminders scheduled for today by priority first

      Commands without tab completion (rarely used)

      - export           : export data to '#{DB_EXPORT_PATH}'
      - import           : restore data from '#{DB_EXPORT_PATH}'
      EOS
    when 'ls'
      table(all_by_trigger_on)
    when 'ls2'
      table(all_by_priority)
    when 'due'
      table(overdues_by_priority)
    when 'due2'
      table(overdues_by_trigger_on)
    when 'today'
      table(scheduled_today_by_trigger_on)
    when 'today2'
      table(scheduled_today_by_priority)
    when 'export'
      CSV.open(DB_EXPORT_PATH, 'wb') do |csv|
        csv << ['priority', 'trigger_on', 'descr' ]
        Reminder.all do |r|
          csv << [r.priority, r.trigger_on, r.descr]
        end
      end
      p(:OK)
      print("Inspect export? (y|N)")
      answer = gets.chomp
      if answer == 'y'
        # apt install csvtool
        puts `csvtool readable "#{DB_EXPORT_PATH}"`

        # pip install tabview
        # system('tabview', DB_EXPORT_PATH)
      end
    when 'import'
      CSV.foreach(DB_EXPORT_PATH, headers: true) do |row|

        Reminder.insert(
          pos: Reminder.next_available_pos,
          descr: row.fetch('descr'),
          trigger_on: row.fetch('trigger_on'),
          priority: row.fetch('priority'),
        )
      end
    else
      if (m = /^!(?<pos>\d+)/.match(cmd)) # delete
        # Don't like log message of query below (generates 2 queries, confusing UI wise)
        DB.logger = nil
        Reminder.find(pos: m[:pos]).delete
        DB.logger = Logger.new(STDOUT)
        p(:DELETE_OK)
        table(overdues_by_priority)

        next
      elsif (m = /^>(?<pos>\d+)\s(?<code>\d+[mhd])/.match(cmd)) # reschedule
        now = Time.now
        r = Reminder.find(pos: m[:pos])

        code = m[:code]
        suffix = code[-1]
        i = Integer(code[0..-2])
        next_trigger_on = case suffix
                          when 'm'
                            now + i*ONE_MINUTE
                          when 'h'
                            now + i*ONE_HOUR
                          when 'd'
                            now + i*ONE_DAY
                          else
                            fail 'Impossible'
                          end
        res = r.update(trigger_on: next_trigger_on)
        ap(res)
        table(overdues_by_priority)
        next
      elsif (m = /^(?<pos>\d+)/.match(cmd)) # edit
        loop do
          r, h = edit_reminder(m[:pos])
          ap(h)
          r.descr = h.fetch(:descr)
          r.trigger_on = h.fetch(:trigger_on)
          r.priority =  h.fetch(:priority)
          if r.valid?
            r.save
            break
          end
          ap(r.errors)
        end
        table(overdues_by_priority)
        next
      end

      r = build_reminder(descr: cmd, trigger_on: Time.now + ONE_HOUR, priority: 0)
      ap(r)
      Reminder.insert(
        pos: Reminder.next_available_pos,
        descr: r.fetch(:descr),
        trigger_on: r.fetch(:trigger_on),
        priority: r.fetch(:priority),
      )
    end
  end
end

def run_notifier!
  loop do
    overdues = overdues_by_priority
    overdues.each do |o|
      `notify-send -u critical "[#{o.pos}] Priority=#{o.priority}: #{o.descr}"`
    end
    sleep(1)
  end
end

if args.notify
  run_notifier!
  fail 'Impossible'
end

run_cli
